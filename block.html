<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Enjoy Puzzle - Better Drag</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Ìè∞Ìä∏ Î∞è ÏïÑÏù¥ÏΩò -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css" type="text/css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        body { 
            font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, system-ui, Roboto, "Helvetica Neue", "Segoe UI", "Apple SD Gothic Neo", "Noto Sans KR", "Malgun Gothic", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", sans-serif;
            background: #F2F4F6;
            color: #191F28;
            -webkit-tap-highlight-color: transparent;
            overscroll-behavior-y: none;
            touch-action: pan-y;
            user-select: none;
            -webkit-user-select: none;
            overflow: hidden;
            height: 100dvh;
            display: flex;
            flex-direction: column;
        }

        /* --- Components --- */
        .glass-card {
            background: rgba(255, 255, 255, 0.4);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.6);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.05);
            border-radius: 24px;
        }

        .account-card-gradient {
            background: linear-gradient(135deg, #333d4b 0%, #191f28 100%);
            color: white;
            box-shadow: 0 10px 30px -5px rgba(25, 31, 40, 0.3);
            border-radius: 24px;
        }

        .text-main { color: #191F28; }
        .text-sub { color: #6B7684; }
        .text-blue { color: #3182F6; }

        .btn-primary {
            background-color: #3182F6;
            color: white;
            font-weight: 700;
            border-radius: 16px;
            transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
            box-shadow: 0 4px 12px rgba(49, 130, 246, 0.2);
        }
        .btn-primary:active {
            transform: scale(0.96);
            background-color: #1b64da;
        }

        .modal-overlay {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }

        /* --- Game Board Styles --- */
        #board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 3px;
            background-color: rgba(25, 31, 40, 0.05);
            padding: 6px; /* Ïù¥ Ìå®Îî©Í∞í(6px)Ïù¥ Ï¢åÌëú Í≥ÑÏÇ∞Ïùò ÌïµÏã¨ÏûÖÎãàÎã§ */
            border-radius: 20px;
            width: 100%;
            height: 100%;
            aspect-ratio: 1;
            margin: 0 auto;
            position: relative;
        }

        .cell {
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 6px;
            width: 100%;
            height: 100%;
            position: relative;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.05);
        }

        /* Jewel Styles */
        .block-cell {
            width: 100%; height: 100%; border-radius: 6px; position: relative; box-sizing: border-box;
            box-shadow: inset 2px 2px 5px rgba(255,255,255,0.4), inset -2px -2px 5px rgba(0,0,0,0.1), 0 2px 4px rgba(0,0,0,0.15);
            border: 1px solid rgba(255,255,255,0.2);
        }
        .block-cell::after {
            content: ''; position: absolute; top: 15%; left: 15%; width: 30%; height: 30%;
            background: radial-gradient(circle, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0) 70%);
            border-radius: 50%; opacity: 0.7;
        }

        /* Block Colors */
        .color-1 { background: linear-gradient(135deg, #FF6B6B, #EE5253); }
        .color-2 { background: linear-gradient(135deg, #FF9F43, #F368E0); }
        .color-3 { background: linear-gradient(135deg, #54A0FF, #2E86DE); }
        .color-4 { background: linear-gradient(135deg, #1DD1A1, #10AC84); }
        .color-5 { background: linear-gradient(135deg, #FECA57, #FF9F43); }
        .color-6 { background: linear-gradient(135deg, #5f27cd, #341f97); }
        .color-7 { background: linear-gradient(135deg, #00d2d3, #01a3a4); }

        .preview-container {
            height: 90px;
            display: flex; justify-content: space-around; align-items: center; width: 100%; padding: 0 10px;
        }
        .shape-preview { position: relative; touch-action: none; transition: transform 0.1s; }
        .shape-preview:active { transform: scale(0.9); }
        .ghost { opacity: 0.4; filter: grayscale(20%); }
        .dragging-mirror {
            position: fixed; pointer-events: none; z-index: 1000; opacity: 0.95; display: grid; box-sizing: border-box;
            transform: translate(-50%, -50%) scale(1.1); filter: drop-shadow(0 10px 20px rgba(0,0,0,0.2));
        }

        .clearing-flash { animation: flashAnim 0.2s ease-out forwards; z-index: 10; }
        @keyframes flashAnim {
            0% { transform: scale(1); filter: brightness(1); }
            50% { transform: scale(1.1); filter: brightness(2); background-color: #fff; }
            100% { transform: scale(0.8); opacity: 0; }
        }
        .particle { position: fixed; width: 8px; height: 8px; border-radius: 2px; pointer-events: none; z-index: 1001; transition: transform 0.6s cubic-bezier(0.165, 0.84, 0.44, 1), opacity 0.6s ease-in; }

        .custom-input {
            width: 100%; background: #F9FAFB; border: 1px solid #E5E8EB; border-radius: 16px; padding: 16px;
            font-size: 18px; font-weight: 600; color: #191F28; text-align: center; outline: none; transition: all 0.2s;
        }
        .custom-input:focus { border-color: #3182F6; background: #fff; box-shadow: 0 0 0 2px rgba(49, 130, 246, 0.1); }
        .shake-effect { animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake { 10%, 90% { transform: translate3d(-1px, 0, 0); } 20%, 80% { transform: translate3d(2px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-4px, 0, 0); } 40%, 60% { transform: translate3d(4px, 0, 0); } }
        
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
    </style>
</head>
<body class="safe-area-inset-bottom bg-[#F2F4F6]">

    <!-- VIEW 1: HOME (LOBBY) -->
    <main id="home-view" class="flex-1 w-full flex flex-col pt-12 px-5 overflow-y-auto scrollbar-hide pb-24">
        
        <div class="flex justify-between items-center mb-6 shrink-0">
            <h1 class="text-2xl font-bold text-main">Î∏îÎü≠Í≤ú</h1>
            <div id="home-user-badge" class="bg-white px-3 py-1.5 rounded-full text-xs font-bold text-gray-500 shadow-sm border border-gray-100 cursor-pointer" onclick="openLoginModal()">
                Î°úÍ∑∏Ïù∏ ÌïÑÏöî
            </div>
        </div>

        <div onclick="startGameSession()" class="w-full bg-gradient-to-br from-[#E6F4FF] to-[#F0F7FF] p-6 rounded-[26px] shadow-sm border border-blue-100 relative overflow-hidden group active:scale-[0.98] transition-transform duration-200 cursor-pointer mb-8 shrink-0">
            <div class="absolute right-[-10px] bottom-[-20px] text-[100px] opacity-20 rotate-[-10deg]">üß©</div>
            <div class="relative z-10">
                <span class="inline-flex items-center gap-1.5 bg-blue-500 text-white text-[10px] font-bold px-2 py-0.5 rounded-full mb-3">
                    NEW
                </span>
                <h2 class="text-2xl font-extrabold text-[#191F28] leading-tight mb-2">
                    ÏóîÏ°∞Ïù¥ Î∏îÎ°ù ÌçºÏ¶ê<br>
                    <span class="text-blue-500">Ìïú Ìåê ÏäπÎ∂Ä!</span>
                </h2>
                <p class="text-sm text-gray-500 font-medium">
                    ÎÇ¥Í∏∞ Ìïú Ìåê Ïñ¥ÎïåÏöî? 1Îì±ÏùÑ ÎÖ∏Î†§Î≥¥ÏÑ∏Ïöî!
                </p>
                <div class="mt-5 inline-flex items-center gap-2 text-sm font-bold text-blue-600 bg-white/50 px-4 py-2 rounded-full backdrop-blur-sm">
                    ÌîåÎ†àÏù¥ ÌïòÎü¨ Í∞ÄÍ∏∞ <i class="fa-solid fa-arrow-right"></i>
                </div>
            </div>
        </div>

        <div class="w-full shrink-0">
            <div class="flex justify-between items-end mb-3 px-1">
                <h3 class="text-lg font-bold text-main">Ï†ÑÏ≤¥ ÏàúÏúÑ üèÜ</h3>
                <span class="text-xs text-gray-400">Ï∞∏Í∞ÄÏûê 6Î™Ö</span>
            </div>
            <div id="home-ranking-list" class="space-y-3 pb-4">
                <div class="p-4 text-center text-gray-400 text-xs">
                    ÏÑúÎ≤Ñ Ïó∞Í≤∞ Ï§ë...
                </div>
            </div>
        </div>
        <div class="h-10 shrink-0"></div>
    </main>

    <!-- VIEW 2: GAMEPLAY -->
    <main id="gameplay-view" class="hidden flex-1 w-full flex-col items-center px-4 pt-4 pb-20 overflow-hidden h-full fixed top-0 left-0 bg-[#F2F4F6] z-50">
        
        <div class="w-full max-w-md flex justify-between items-center mb-2 px-1 shrink-0 mt-8">
            <button onclick="exitGameSession()" class="px-3 py-1.5 rounded-full bg-gray-200/50 hover:bg-gray-200 text-gray-600 text-xs font-bold transition-colors">
                <i class="fa-solid fa-chevron-left mr-1"></i> Î°úÎπÑ
            </button>
            <div class="flex items-center gap-2">
                <button onclick="restartGame()" class="w-9 h-9 rounded-full bg-white hover:bg-gray-50 flex items-center justify-center text-gray-600 shadow-sm transition-all active:scale-90 active:rotate-180">
                    <i class="fa-solid fa-rotate-right text-sm"></i>
                </button>
            </div>
        </div>

        <div class="flex-1 w-full max-w-md flex flex-col justify-center items-center gap-3 min-h-0">
            <div class="w-full account-card-gradient p-5 shadow-lg shrink-0 flex items-center justify-between relative overflow-hidden">
                 <div class="absolute right-[-10px] top-[-10px] w-32 h-32 bg-white/10 rounded-full blur-2xl pointer-events-none"></div>
                 <div class="relative z-10">
                     <p class="text-xs text-gray-300 font-medium mb-1">ÌòÑÏû¨ Ï†êÏàò</p>
                     <h2 id="current-score" class="text-3xl font-bold text-white tabular-nums leading-none tracking-tight">0</h2>
                 </div>
                 <div class="relative z-10 text-right">
                     <p class="text-[10px] text-gray-400 font-medium mb-1">ÎÇ¥ ÏµúÍ≥† Ï†êÏàò</p>
                     <p id="best-score" class="text-xl font-bold text-blue-300 tabular-nums leading-none">0</p>
                 </div>
            </div>

            <div class="glass-card p-3 w-full aspect-square flex items-center justify-center shadow-lg ring-1 ring-white/40 shrink-0 bg-white/20">
                <div id="board"></div>
            </div>

            <div class="w-full glass-card h-[90px] flex items-center justify-center ring-1 ring-white/40 shrink-0 bg-white/20">
                <div class="preview-container" id="inventory"></div>
            </div>
        </div>
    </main>

    <!-- Bottom Navigation -->
    <nav id="bottom-nav" class="fixed bottom-2 left-1/2 -translate-x-1/2 z-40 w-auto touch-pan-x select-none">
        <div class="flex items-center bg-white/10 backdrop-blur-[4px] backdrop-saturate-[180%] shadow-[0_8px_32px_0_rgba(31,38,135,0.15)] border border-white/20 rounded-full p-1 gap-1 ring-1 ring-white/30 relative">
            <div id="nav-indicator" class="absolute top-1 bottom-1 bg-white/50 shadow-[inset_0_1px_1px_rgba(255,255,255,0.8)] rounded-full backdrop-blur-[2px] border border-white/20 z-0" style="right: 4px; width: 64px;"></div>
            
            <a href="index.html" class="relative px-6 py-1.5 rounded-full group min-w-[64px] z-10 active:scale-95 transition-transform flex flex-col items-center gap-0.5">
                <i class="fa-solid fa-house text-lg text-gray-400 transition-colors"></i>
                <span class="text-[10px] font-medium text-gray-400 transition-colors whitespace-nowrap">Ìôà</span>
            </a>

            <button onclick="exitGameSession()" class="relative px-6 py-1.5 rounded-full group min-w-[64px] z-10 cursor-pointer">
                <div class="flex flex-col items-center gap-0.5 pointer-events-none">
                    <i class="fa-solid fa-gamepad text-lg text-[#191F28]"></i>
                    <span class="text-[10px] font-bold text-[#191F28] whitespace-nowrap">Í≤åÏûÑ</span>
                </div>
            </button>
        </div>
    </nav>

    <!-- Modals -->
    <div id="login-modal" class="modal-overlay fixed inset-0 flex items-center justify-center z-50">
        <div class="bg-white p-6 rounded-[28px] shadow-2xl text-center w-full max-w-[300px] scale-in mx-4">
            <div class="w-14 h-14 rounded-[20px] bg-blue-50 text-blue-500 flex items-center justify-center text-2xl mx-auto mb-4 shadow-sm">
                <i class="fa-solid fa-puzzle-piece"></i>
            </div>
            <h2 class="text-xl font-bold text-main mb-2">ÎàÑÍµ¨ÏÑ∏Ïöî?</h2>
            <p class="text-sub text-xs mb-5">ÏàúÏúÑ Í∏∞Î°ùÏùÑ ÏúÑÌï¥ Ïù¥Î¶ÑÏùÑ ÏïåÎ†§Ï£ºÏÑ∏Ïöî</p>
            <div class="flex flex-col gap-3">
                <input type="text" id="username-input" placeholder="Ïù¥Î¶Ñ ÏûÖÎ†•" class="custom-input py-3 text-base" onkeypress="handleEnter(event)">
                <button onclick="submitLogin()" class="btn-primary w-full py-3.5 text-base shadow-md">ÏãúÏûëÌïòÍ∏∞</button>
            </div>
        </div>
    </div>

    <div id="game-over-modal" class="modal-overlay fixed inset-0 hidden flex items-center justify-center z-[60]">
        <div class="bg-white p-6 rounded-[28px] shadow-2xl text-center w-full max-w-[300px] scale-in mx-4">
            <h2 class="text-2xl font-black text-main mb-1">GAME OVER</h2>
            <p class="text-sub text-xs mb-5">ÏàòÍ≥†ÌñàÏñ¥Ïöî, <span id="go-player-name" class="font-bold text-blue-500"></span>Îãò!</p>
            <div class="bg-gray-50 rounded-2xl p-4 mb-5 border border-gray-100">
                <div class="text-xs text-gray-400 mb-1 font-bold">ÏµúÏ¢Ö Ï†êÏàò</div>
                <div id="final-score" class="text-3xl font-bold text-main tabular-nums">0</div>
            </div>
            <div class="text-left mb-5">
                <div class="text-xs text-gray-400 font-bold mb-2 ml-1">üèÜ Ïã§ÏãúÍ∞Ñ Top 3</div>
                <div id="leaderboard-list" class="space-y-1.5"></div>
            </div>
            <div class="flex gap-2">
                <button onclick="exitGameSession(); document.getElementById('game-over-modal').classList.add('hidden');" class="flex-1 bg-gray-100 text-gray-600 font-bold py-3 rounded-xl text-xs hover:bg-gray-200">ÎÇòÍ∞ÄÍ∏∞</button>
                <button onclick="restartGame()" class="flex-[1.5] btn-primary py-3 rounded-xl text-sm shadow-md">Îã§Ïãú ÌïòÍ∏∞</button>
            </div>
        </div>
    </div>

    <!-- Firebase Integration -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInWithCustomToken, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, doc, setDoc, onSnapshot, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyBDn155v1pwBwPjPtm7kL3HEaZSx3HGdm8",
            authDomain: "enjoyblockpuzzle-cd704.firebaseapp.com",
            projectId: "enjoyblockpuzzle-cd704",
            storageBucket: "enjoyblockpuzzle-cd704.firebasestorage.app",
            messagingSenderId: "199349096820",
            appId: "1:199349096820:web:013c248f07d8bcb2871c21"
        };
        
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        
        let currentPlayer = "";
        let currentBestScore = 0;
        const initialPlayers = ["Ï†ÑÏãúÍ∏∞", "ÏÑ±ÏõêÏ†ú", "ÌôçÎ∞ïÏÇ¨", "Ïù¥ÏßÑÎàÑ", "Ïò§Ïä§Ìã¥", "Î•òÏß±"];
        let globalRanking = initialPlayers.map(name => ({ name, score: 0 }));

        async function initApp() {
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }

                if (!auth.currentUser) return;

                const scoresRef = collection(db, 'block_scores');
                onSnapshot(scoresRef, (snapshot) => {
                    const cloudData = [];
                    snapshot.forEach(doc => cloudData.push(doc.data()));
                    const mergedMap = new Map();
                    initialPlayers.forEach(name => mergedMap.set(name, { name, score: 0 }));
                    cloudData.forEach(data => {
                        mergedMap.set(data.name, { name: data.name, score: data.score });
                    });
                    globalRanking = Array.from(mergedMap.values()).sort((a, b) => b.score - a.score);
                    updateLeaderboardUI();
                    if (currentPlayer) {
                        const myRecord = globalRanking.find(d => d.name === currentPlayer);
                        if (myRecord) {
                            currentBestScore = myRecord.score;
                            document.getElementById('best-score').innerText = currentBestScore.toLocaleString();
                        }
                    }
                });
            } catch (e) {
                console.error("Auth error:", e);
                updateLeaderboardUI(); 
            }
        }

        window.saveScoreToCloud = async function(newScore) {
            if (!currentPlayer || !auth.currentUser) return;
            if (newScore > currentBestScore) {
                currentBestScore = newScore;
                document.getElementById('best-score').innerText = currentBestScore.toLocaleString();
                try {
                    const docRef = doc(db, 'block_scores', currentPlayer);
                    await setDoc(docRef, {
                        name: currentPlayer,
                        score: newScore,
                        updatedAt: serverTimestamp()
                    });
                } catch (e) { console.error(e); }
            }
        }

        window.updateLeaderboardUI = function() {
            const listEl = document.getElementById('home-ranking-list');
            const miniListEl = document.getElementById('leaderboard-list');
            
            const generateHTML = (data, limit = 100) => {
                return data.slice(0, limit).map((entry, idx) => {
                    let rankBadge = `<span class="text-gray-500 font-bold text-sm w-6 text-center">${idx+1}</span>`;
                    if(idx === 0) rankBadge = 'ü•á';
                    if(idx === 1) rankBadge = 'ü•à';
                    if(idx === 2) rankBadge = 'ü•â';
                    const isMe = entry.name === currentPlayer ? 'bg-blue-50 border border-blue-100' : 'bg-white';
                    return `
                        <div class="glass-card p-3 flex justify-between items-center ${isMe} mb-2">
                            <div class="flex items-center gap-3">
                                <span class="text-lg w-6 text-center">${rankBadge}</span>
                                <span class="text-sm font-bold text-main">${entry.name}</span>
                            </div>
                            <span class="text-sm font-bold text-blue-500 tabular-nums">${entry.score.toLocaleString()}</span>
                        </div>
                    `;
                }).join('');
            };
            if(listEl) listEl.innerHTML = generateHTML(globalRanking);
            if(miniListEl) miniListEl.innerHTML = generateHTML(globalRanking, 3);
        }

        window.handleEnter = function(e) { if (e.key === 'Enter') window.submitLogin(); }
        
        window.submitLogin = function() {
            if(window.haptic) window.haptic();
            const input = document.getElementById('username-input');
            const name = input.value.trim();
            if (!name) {
                input.classList.add('shake-effect');
                setTimeout(() => input.classList.remove('shake-effect'), 500);
                return;
            }
            localStorage.setItem('enjoy_puzzle_username', name);
            window.login(name);
        }

        window.login = function(name) {
            currentPlayer = name;
            document.getElementById('home-user-badge').innerText = `üëã ${name}`;
            document.getElementById('login-modal').classList.add('hidden');
            const myRecord = globalRanking.find(d => d.name === currentPlayer);
            if (myRecord) {
                currentBestScore = myRecord.score;
                document.getElementById('best-score').innerText = currentBestScore.toLocaleString();
            } else {
                currentBestScore = 0;
                document.getElementById('best-score').innerText = "0";
            }
            updateLeaderboardUI();
        }

        initApp();
        const savedName = localStorage.getItem('enjoy_puzzle_username');
        if (savedName) window.login(savedName);
        else setTimeout(() => document.getElementById('login-modal').classList.remove('hidden'), 300);
    </script>

    <script>
        function startGameSession() {
            if(window.haptic) window.haptic();
            document.getElementById('home-view').classList.add('hidden');
            document.getElementById('gameplay-view').classList.remove('hidden');
            document.getElementById('gameplay-view').classList.add('flex');
            setTimeout(() => window.dispatchEvent(new Event('resize')), 50);
        }

        function exitGameSession() {
            if(window.haptic) window.haptic();
            document.getElementById('gameplay-view').classList.add('hidden');
            document.getElementById('gameplay-view').classList.remove('flex');
            document.getElementById('home-view').classList.remove('hidden');
            if(window.updateLeaderboardUI) window.updateLeaderboardUI();
        }

        function openLoginModal() {
            document.getElementById('login-modal').classList.remove('hidden');
            setTimeout(() => document.getElementById('username-input').focus(), 100);
        }

        window.haptic = function() { if (navigator.vibrate) navigator.vibrate(5); }
        
        const BOARD_SIZE = 8;
        const GAP_SIZE = 3;
        const PADDING_SIZE = 6; // Important for Drag Correction
        const COLORS = ['color-1', 'color-2', 'color-3', 'color-4', 'color-5', 'color-6', 'color-7'];
        
        const SHAPES = [
            { m: [[1]], id: 'single' }, { m: [[1, 1]], id: 'h2' }, { m: [[1], [1]], id: 'v2' },
            { m: [[1, 1, 1]], id: 'h3' }, { m: [[1], [1], [1]], id: 'v3' },
            { m: [[1, 1, 1, 1]], id: 'h4' }, { m: [[1], [1], [1], [1]], id: 'v4' },
            { m: [[1, 1, 1, 1, 1]], id: 'h5' }, { m: [[1], [1], [1], [1], [1]], id: 'v5' },
            { m: [[1, 1], [1, 1]], id: 'sq2' }, { m: [[1, 1, 1], [1, 1, 1], [1, 1, 1]], id: 'sq3' },
            { m: [[1, 0], [1, 0], [1, 1]], id: 'l_big_1' }, { m: [[1, 1, 1], [1, 0, 0]], id: 'l_big_2' },
            { m: [[1, 1], [0, 1], [0, 1]], id: 'l_big_3' }, { m: [[0, 0, 1], [1, 1, 1]], id: 'l_big_4' },
            { m: [[1, 0], [1, 1]], id: 'l_small_1' }, { m: [[0, 1], [1, 1]], id: 'l_small_2' },
            { m: [[1, 1], [1, 0]], id: 'l_small_3' }, { m: [[1, 1], [0, 1]], id: 'l_small_4' },
            { m: [[1, 1, 1], [0, 1, 0]], id: 't_up' }, { m: [[0, 1], [1, 1], [0, 1]], id: 't_left' },
            { m: [[1, 0], [1, 1], [1, 0]], id: 't_right' }, { m: [[0, 1, 0], [1, 1, 1]], id: 't_down' },
            { m: [[0, 1, 0], [1, 1, 1], [0, 1, 0]], id: 'plus' },
            { m: [[1, 1, 0], [0, 1, 1]], id: 'z_1' }, { m: [[0, 1, 1], [1, 1, 0]], id: 's_1' },
            { m: [[1, 0], [1, 1], [0, 1]], id: 'z_v' }, { m: [[0, 1], [1, 1], [1, 0]], id: 's_v' },
            { m: [[1, 0], [0, 1]], id: 'diag_2' }, { m: [[0, 1], [1, 0]], id: 'diag_2_r' },
            { m: [[1, 0, 0], [0, 1, 0], [0, 0, 1]], id: 'diag_3' }
        ];

        let boardGrid = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(null));
        let score = 0;
        let inventory = [null, null, null];

        const boardEl = document.getElementById('board');
        const inventoryEl = document.getElementById('inventory');
        const scoreEl = document.getElementById('current-score');
        const finalScoreEl = document.getElementById('final-score');
        const goPlayerNameEl = document.getElementById('go-player-name');
        const modalEl = document.getElementById('game-over-modal');

        function initGame() {
            renderBoard();
            generateNewShapes();
        }

        function restartGame() {
            if(window.haptic) window.haptic();
            boardGrid = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(null));
            score = 0;
            scoreEl.innerText = 0;
            modalEl.classList.add('hidden');
            Array.from(boardEl.children).forEach(cell => cell.innerHTML = '');
            generateNewShapes();
        }

        function renderBoard() {
            boardEl.innerHTML = '';
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.r = r;
                    cell.dataset.c = c;
                    boardEl.appendChild(cell);
                }
            }
        }

        function generateNewShapes() {
            inventory = [];
            inventoryEl.innerHTML = '';
            for (let i = 0; i < 3; i++) {
                const shape = SHAPES[Math.floor(Math.random() * SHAPES.length)];
                const color = COLORS[Math.floor(Math.random() * COLORS.length)];
                const shapeData = { matrix: shape.m, color: color, id: i };
                inventory.push(shapeData);
                const el = createShapeElement(shapeData, i, true); 
                inventoryEl.appendChild(el);
            }
            checkGameOver();
        }

        function createShapeElement(shapeData, index, isPreview) {
            const container = document.createElement('div');
            container.className = isPreview ? 'shape-preview' : 'dragging-mirror';
            if (isPreview) container.dataset.index = index;

            const rows = shapeData.matrix.length;
            const cols = shapeData.matrix[0].length;
            let cellSize = 18; let gap = 2;

            if (!isPreview) {
                const firstCell = boardEl.querySelector('.cell');
                if(firstCell) {
                    cellSize = firstCell.getBoundingClientRect().width;
                    gap = GAP_SIZE;
                }
            }

            container.style.gridTemplateColumns = `repeat(${cols}, ${cellSize}px)`;
            container.style.gridTemplateRows = `repeat(${rows}, ${cellSize}px)`;
            container.style.gap = `${gap}px`;
            
            if(isPreview) {
                container.style.display = 'grid';
                container.style.width = `${cols * cellSize + (cols-1)*gap}px`;
                container.style.height = `${rows * cellSize + (rows-1)*gap}px`;
            }

            shapeData.matrix.forEach(row => {
                row.forEach(val => {
                    const cell = document.createElement('div');
                    if (val === 1) cell.className = `block-cell ${shapeData.color}`;
                    else { cell.style.width = '100%'; cell.style.height = '100%'; }
                    container.appendChild(cell);
                });
            });

            if (isPreview) {
                container.addEventListener('mousedown', startDrag);
                container.addEventListener('touchstart', startDrag, { passive: false });
            }
            return container;
        }

        let draggedItem = null; let mirrorElement = null; let currentShapeData = null;

        function startDrag(e) {
            e.preventDefault();
            if(window.haptic) window.haptic();
            const index = this.dataset.index;
            if (!inventory[index]) return;
            draggedItem = this;
            currentShapeData = inventory[index];
            mirrorElement = createShapeElement(currentShapeData, null, false);
            document.body.appendChild(mirrorElement);
            draggedItem.style.opacity = '0';
            moveMirror(e);
            document.addEventListener('mousemove', onDrag);
            document.addEventListener('touchmove', onDrag, { passive: false });
            document.addEventListener('mouseup', endDrag);
            document.addEventListener('touchend', endDrag);
        }

        function moveMirror(e) {
            if (!mirrorElement) return;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const offsetY = e.touches ? 60 : 0; 
            mirrorElement.style.left = `${clientX}px`;
            mirrorElement.style.top = `${clientY - offsetY}px`;
        }

        function onDrag(e) {
            e.preventDefault();
            moveMirror(e);
            const mirrorRect = mirrorElement.getBoundingClientRect();
            const centerX = mirrorRect.left + mirrorRect.width / 2;
            const centerY = mirrorRect.top + mirrorRect.height / 2;
            highlightHover(centerX, centerY);
        }

        // --- Improved Drag Snapping Logic ---
        function highlightHover(x, y) {
            document.querySelectorAll('.ghost').forEach(el => el.remove());
            const targetPos = getBestFitPosition(x, y);
            if (targetPos) {
                drawGhost(targetPos.r, targetPos.c, currentShapeData.matrix, currentShapeData.color);
            }
        }

        function getBestFitPosition(x, y) {
            const boardRect = boardEl.getBoundingClientRect();
            
            // Basic bound check
            if (x < boardRect.left - 50 || x > boardRect.right + 50 || y < boardRect.top - 50 || y > boardRect.bottom + 50) return null;

            const firstCell = boardEl.querySelector('.cell');
            const cellFullSize = firstCell.getBoundingClientRect().width + GAP_SIZE;
            
            // Calculate hypothetical grid coordinate based on center
            // Corrected padding offset: PADDING_SIZE (6)
            const relX = x - boardRect.left - PADDING_SIZE;
            const relY = y - boardRect.top - PADDING_SIZE;
            
            // Shape center relative to its top-left
            const shapePixelW = currentShapeData.matrix[0].length * cellFullSize - GAP_SIZE;
            const shapePixelH = currentShapeData.matrix.length * cellFullSize - GAP_SIZE;
            
            // We want top-left of the shape in grid coords
            // (Center - HalfShape)
            const targetPixelX = relX - shapePixelW / 2;
            const targetPixelY = relY - shapePixelH / 2;
            
            const c = Math.round(targetPixelX / cellFullSize);
            const r = Math.round(targetPixelY / cellFullSize);
            
            // Validate
            if (canPlace(r, c, currentShapeData.matrix)) {
                return { r, c };
            }
            
            // Smart Snap: If exact round fails, check neighbors (Magnet)
            // This fixes "slightly off" touches
            const neighbors = [
                {r: r+1, c: c}, {r: r-1, c: c}, 
                {r: r, c: c+1}, {r: r, c: c-1}
            ];
            
            for(let n of neighbors) {
                if(canPlace(n.r, n.c, currentShapeData.matrix)) return n;
            }

            return null;
        }

        function drawGhost(r, c, matrix, color) {
            for(let i=0; i<matrix.length; i++) {
                for(let j=0; j<matrix[0].length; j++) {
                    if(matrix[i][j] === 1) {
                         const cell = getCell(r+i, c+j);
                         if(cell) {
                             const ghost = document.createElement('div');
                             ghost.className = `block-cell ${color} ghost`;
                             cell.appendChild(ghost);
                         }
                    }
                }
            }
        }

        function getCell(r, c) {
            if (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE) return null;
            return boardEl.children[r * BOARD_SIZE + c];
        }

        function endDrag(e) {
            document.removeEventListener('mousemove', onDrag);
            document.removeEventListener('touchmove', onDrag);
            document.removeEventListener('mouseup', endDrag);
            document.removeEventListener('touchend', endDrag);
            document.querySelectorAll('.ghost').forEach(el => el.remove());

            let placed = false;
            if (mirrorElement) {
                const mirrorRect = mirrorElement.getBoundingClientRect();
                const centerX = mirrorRect.left + mirrorRect.width / 2;
                const centerY = mirrorRect.top + mirrorRect.height / 2;
                
                const targetPos = getBestFitPosition(centerX, centerY);

                if (targetPos) {
                    if(window.haptic) window.haptic();
                    placeBlock(targetPos.r, targetPos.c, currentShapeData);
                    placed = true;
                    inventory[draggedItem.dataset.index] = null;
                    draggedItem.remove();
                    if (inventory.every(item => item === null)) generateNewShapes();
                    else checkGameOver();
                }
            }
            if (!placed && draggedItem) draggedItem.style.opacity = '1';
            if (mirrorElement) mirrorElement.remove();
            mirrorElement = null; draggedItem = null; currentShapeData = null;
        }

        function canPlace(r, c, matrix) {
            for (let i = 0; i < matrix.length; i++) {
                for (let j = 0; j < matrix[0].length; j++) {
                    if (matrix[i][j] === 1) {
                        let nr = r + i; let nc = c + j;
                        if (nr < 0 || nr >= BOARD_SIZE || nc < 0 || nc >= BOARD_SIZE) return false;
                        if (boardGrid[nr][nc] !== null) return false;
                    }
                }
            }
            return true;
        }

        function placeBlock(r, c, shapeData) {
            let points = 0;
            for (let i = 0; i < shapeData.matrix.length; i++) {
                for (let j = 0; j < shapeData.matrix[0].length; j++) {
                    if (shapeData.matrix[i][j] === 1) {
                        boardGrid[r+i][c+j] = shapeData.color;
                        points++;
                        const cell = getCell(r+i, c+j);
                        cell.innerHTML = '';
                        const block = document.createElement('div');
                        block.className = `block-cell ${shapeData.color}`;
                        cell.appendChild(block);
                    }
                }
            }
            score += points;
            scoreEl.innerText = score.toLocaleString();
            if(window.saveScoreToCloud) window.saveScoreToCloud(score); // Save Realtime
            checkLines();
        }

        function checkLines() {
            let rowsToClear = [], colsToClear = [];
            for (let r = 0; r < BOARD_SIZE; r++) if (boardGrid[r].every(val => val !== null)) rowsToClear.push(r);
            for (let c = 0; c < BOARD_SIZE; c++) {
                let full = true;
                for (let r = 0; r < BOARD_SIZE; r++) if (boardGrid[r][c] === null) { full = false; break; }
                if (full) colsToClear.push(c);
            }

            if (rowsToClear.length > 0 || colsToClear.length > 0) {
                if(window.haptic) window.haptic();
                const totalLines = rowsToClear.length + colsToClear.length;
                const bonus = totalLines > 1 ? totalLines * 20 : 0;
                score += (totalLines * 100) + bonus;
                scoreEl.innerText = score.toLocaleString();
                if(window.saveScoreToCloud) window.saveScoreToCloud(score); // Save Realtime

                const boardEl = document.getElementById('board');
                boardEl.classList.remove('shake-effect');
                void boardEl.offsetWidth; boardEl.classList.add('shake-effect');
                setTimeout(() => boardEl.classList.remove('shake-effect'), 500);

                const cellsToClear = new Set();
                rowsToClear.forEach(r => {
                    for(let c=0; c<BOARD_SIZE; c++) {
                        const cell = getCell(r, c);
                        if(cell && cell.firstChild) cellsToClear.add({el: cell.firstChild, color: boardGrid[r][c]});
                        boardGrid[r][c] = null;
                    }
                });
                colsToClear.forEach(c => {
                    for(let r=0; r<BOARD_SIZE; r++) {
                        const cell = getCell(r, c);
                        if(cell && cell.firstChild) cellsToClear.add({el: cell.firstChild, color: boardGrid[r][c]});
                        boardGrid[r][c] = null;
                    }
                });
                cellsToClear.forEach(item => {
                    const el = item.el;
                    const color = item.color;
                    el.classList.add('clearing-flash');
                    setTimeout(() => { 
                        createExplosion(el, color); 
                        el.remove(); 
                    }, 150);
                });
            }
        }

        function createExplosion(element, colorClass) {
            const rect = element.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const particleCount = 6 + Math.floor(Math.random() * 3);
            for (let i = 0; i < particleCount; i++) {
                const p = document.createElement('div');
                p.className = `particle ${colorClass}`;
                document.body.appendChild(p);
                p.style.left = `${centerX}px`; p.style.top = `${centerY}px`;
                const angle = Math.random() * Math.PI * 2;
                const velocity = 30 + Math.random() * 50; 
                const tx = Math.cos(angle) * velocity; const ty = Math.sin(angle) * velocity;
                requestAnimationFrame(() => { p.style.transform = `translate(${tx}px, ${ty}px) scale(0)`; p.style.opacity = '0'; });
                setTimeout(() => p.remove(), 600);
            }
        }

        function checkGameOver() {
            const activeShapes = inventory.filter(s => s !== null);
            if (activeShapes.length === 0) return;
            let canMove = false;
            for (let s = 0; s < activeShapes.length; s++) {
                const matrix = activeShapes[s].matrix;
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        if (canPlace(r, c, matrix)) { canMove = true; break; }
                    }
                    if (canMove) break;
                }
                if (canMove) break;
            }
            if (!canMove) {
                setTimeout(() => {
                    finalScoreEl.innerText = score.toLocaleString();
                    const nameInput = document.getElementById('username-input');
                    const currentName = nameInput.value.trim() || "Guest";
                    goPlayerNameEl.innerText = currentName;
                    modalEl.classList.remove('hidden');
                }, 500);
            }
        }

        initGame();
    </script>
</body>
</html>

