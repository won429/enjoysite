<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ÎûôÎèå Î¨ºÎ¶¨ ÏÉåÎìúÎ∞ïÏä§ - ÌîºÎ∞îÎã§ ÏóêÎîîÏÖò</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: 'Segoe UI', sans-serif;
            color: white;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }
        canvas {
            display: block;
        }
        
        #back-btn {
            position: absolute;
            top: 15px;
            left: 15px;
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #555;
            border-radius: 50%;
            color: white;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            padding-bottom: 3px;
            backdrop-filter: blur(4px);
        }

        #ui-panel {
            position: absolute;
            top: 80px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 12px;
            pointer-events: auto;
            border: 1px solid #444;
            display: flex;
            flex-direction: column;
            gap: 10px;
            backdrop-filter: blur(4px);
            max-width: 200px;
        }

        .panel-title {
            font-weight: bold; 
            margin-bottom: 5px; 
            text-align: center;
            display: block;
        }

        .tool-btn {
            background: #333;
            border: 1px solid #555;
            color: #ddd;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            text-align: center;
            white-space: nowrap;
        }
        .tool-btn:active {
            transform: scale(0.95);
        }
        .tool-btn.active {
            background: #007acc;
            border-color: #0099ff;
            color: white;
            font-weight: bold;
        }
        
        /* ÌïµÌè≠ÌÉÑ Î≤ÑÌäº Ïä§ÌÉÄÏùº */
        #btn-nuke {
            background: #442200;
            border-color: #ff8800;
            color: #ffaa00;
            font-weight: bold;
        }
        #btn-nuke.active {
            background: #ff4400;
            color: white;
            box-shadow: 0 0 10px #ff4400;
        }

        .slider-container {
            font-size: 12px;
            color: #aaa;
            margin-top: 5px;
            text-align: center;
        }
        #reset-btn {
            background: #cc3333;
            border-color: #ff4444;
        }

        #info {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: #888;
            pointer-events: none;
            font-size: 0.9rem;
            text-shadow: 0 1px 2px black;
            padding: 0 20px;
            box-sizing: border-box;
        }

        #damage-text {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 24px;
            font-weight: bold;
            color: #ff4444;
            pointer-events: none;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        @media (max-width: 768px) {
            #ui-panel {
                top: auto;
                bottom: 20px;
                left: 10px;
                right: 10px;
                width: auto;
                max-width: none;
                flex-direction: row;
                overflow-x: auto;
                justify-content: flex-start;
                align-items: center;
                padding: 10px;
                gap: 8px;
                -ms-overflow-style: none;
                scrollbar-width: none; 
            }
            #ui-panel::-webkit-scrollbar {
                display: none;
            }

            .panel-title {
                display: none;
            }

            .tool-btn {
                flex: 0 0 auto;
                padding: 8px 12px;
                font-size: 13px;
            }
            
            .slider-container {
                display: none;
            }

            #info {
                top: 15px;
                bottom: auto;
                font-size: 0.8rem;
                padding-left: 60px;
                text-align: left;
                line-height: 1.2;
            }

            #damage-text {
                top: 50px;
                right: 15px;
                font-size: 18px;
            }
        }
    </style>
</head>
<body>

    <button id="back-btn" onclick="location.href='https://won429.github.io/enjoysite/'">&lt;</button>

    <div id="ui-panel">
        <span class="panel-title">ÎèÑÍµ¨</span>
        <button class="tool-btn active" id="btn-drag" onclick="setMode('drag')">‚úã Ïû°Í∏∞</button>
        <button class="tool-btn" id="btn-boom" onclick="setMode('boom')">üí£ Ìè≠Î∞ú</button>
        <button class="tool-btn" id="btn-nuke" onclick="setMode('nuke')">‚ò¢Ô∏è ÌïµÌè≠Î∞ú</button>
        <button class="tool-btn" id="btn-clean" onclick="setMode('clean')">üßπ Ï≤≠ÏÜå</button>
        <button class="tool-btn" id="btn-slow" onclick="toggleSlow()">üê¢ ÎäêÎ¶¨Í≤å</button>
        <button class="tool-btn" id="btn-gravity" onclick="toggleGravity()">üåë Î¨¥Ï§ëÎ†•</button>
        <button class="tool-btn" id="reset-btn" onclick="resetRagdoll()">üîÑ Î¶¨ÏÖã</button>
        <div class="slider-container">
            Î¨ºÎ¶¨ Í∞ïÎèÑ: <span id="stiffness-val">100%</span>
        </div>
    </div>

    <div id="info">Ïû°ÏïÑÎãπÍ∏∞Í±∞ÎÇò(Drag), ÌïµÌè≠ÌÉÑ(Nuke)ÏúºÎ°ú ÎÇ†Î†§Î≤ÑÎ¶¨ÏÑ∏Ïöî!</div>
    <div id="damage-text">Ï∂©Í≤©Îüâ: 0</div>
    
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const damageEl = document.getElementById('damage-text');
        
        let width, height;
        let points = [];
        let sticks = [];
        let particles = [];
        let bloodPuddles = []; 
        
        // ÏÑ§Ï†ï
        const friction = 0.99;
        const bounce = 0.7;
        let gravity = 0.5;
        let originalGravity = 0.5;
        let isSlowMotion = false;
        let mode = 'drag'; // drag, boom, clean, nuke
        let stiffness = 5;
        const breakThreshold = 60; 
        const reassembleDistance = 30;

        // ÏãúÍ∞Å Ìö®Í≥º Î≥ÄÏàò
        let shakeIntensity = 0;
        let flashOpacity = 0;

        // ÏÉÅÌò∏ÏûëÏö©
        let dragPoint = null;
        let mouseX = 0, mouseY = 0;
        let isMouseDown = false;

        // Ïò§ÎîîÏò§
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx;

        function initAudio() {
            if (!audioCtx) audioCtx = new AudioContext();
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }

        function playSound(type, intensity = 1) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const now = audioCtx.currentTime;

            if (type === 'hit') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(100 + Math.random()*50, now);
                osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
                gain.gain.setValueAtTime(Math.min(0.5, intensity * 0.02), now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'boom') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(10, now + 0.3);
                gain.gain.setValueAtTime(1.0 * intensity, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start(now);
                osc.stop(now + 0.3);
            } else if (type === 'break') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 0.15);
                gain.gain.setValueAtTime(0.4, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start(now);
                osc.stop(now + 0.15);
            } else if (type === 'reassemble') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);
                gain.gain.setValueAtTime(0.3, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'clean') {
                const noise = audioCtx.createOscillator();
                noise.type = 'triangle';
                noise.frequency.setValueAtTime(800, now);
                noise.frequency.linearRampToValueAtTime(400, now + 0.1);
                gain.gain.setValueAtTime(0.05, now);
                gain.gain.linearRampToValueAtTime(0.0, now + 0.1);
                noise.connect(gain);
                gain.connect(audioCtx.destination);
                noise.start(now);
                noise.stop(now + 0.1);
            } else if (type === 'nuke_start') {
                // ÌïµÌè≠ÌÉÑ ÏÇ¨Ïù¥Î†å ÎäêÎÇå
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(300, now);
                osc.frequency.linearRampToValueAtTime(600, now + 0.5);
                osc.frequency.linearRampToValueAtTime(300, now + 1.0);
                gain.gain.setValueAtTime(0.5, now);
                gain.gain.linearRampToValueAtTime(0, now + 1.0);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start(now);
                osc.stop(now + 1.0);
            }
        }

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- Î¨ºÎ¶¨ ÏóîÏßÑ ---
        class Point {
            constructor(x, y, radius = 5, isFixed = false) {
                this.x = x;
                this.y = y;
                this.oldx = x; 
                this.oldy = y;
                this.radius = radius;
                this.isFixed = isFixed;
                this.mass = 1;
            }

            update() {
                if (this.isFixed) return;
                
                const vx = (this.x - this.oldx) * friction;
                const vy = (this.y - this.oldy) * friction;

                this.oldx = this.x;
                this.oldy = this.y;

                this.x += vx;
                this.y += vy;
                this.y += gravity; 

                // Î≤Ω Ï∂©Îèå
                let hit = false;
                let impact = 0;

                if (this.x > width - this.radius) {
                    impact = (this.x - this.oldx);
                    this.x = width - this.radius;
                    this.oldx = this.x + vx * bounce;
                    hit = true;
                } else if (this.x < this.radius) {
                    impact = -(this.x - this.oldx);
                    this.x = this.radius;
                    this.oldx = this.x + vx * bounce;
                    hit = true;
                }

                if (this.y > height - this.radius) {
                    impact = (this.y - this.oldy);
                    this.y = height - this.radius;
                    this.oldy = this.y + vy * bounce;
                    hit = true;
                } else if (this.y < this.radius) {
                    impact = -(this.y - this.oldy);
                    this.y = this.radius;
                    this.oldy = this.y + vy * bounce;
                    hit = true;
                }

                if (hit && Math.abs(impact) > 2) {
                    const impactVal = Math.abs(impact);
                    playSound('hit', impactVal);
                    totalDamage += Math.floor(impactVal * 10);
                    updateDamageUI();

                    if (impactVal > 5) {
                        spawnBlood(this.x, this.y, impactVal);
                    }
                }
            }
        }

        class Stick {
            constructor(p1, p2, length, visible = true, width = 2, isBreakable = false) {
                this.p1 = p1;
                this.p2 = p2;
                this.length = length || Math.hypot(p1.x - p2.x, p1.y - p2.y);
                this.visible = visible;
                this.width = width;
                this.color = '#fff';
                this.isBreakable = isBreakable; 
            }

            update() {
                if (!this.visible) return;

                const dx = this.p2.x - this.p1.x;
                const dy = this.p2.y - this.p1.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist === 0) return; 

                const diff = this.length - dist;
                const percent = diff / dist / 2;
                const offsetX = dx * percent;
                const offsetY = dy * percent;

                // Î∂ÄÏÑúÏßê Ï≤¥ÌÅ¨
                if (this.isBreakable && Math.abs(diff) > breakThreshold) {
                    this.visible = false;
                    playSound('break');
                    spawnBlood((this.p1.x + this.p2.x) / 2, (this.p1.y + this.p2.y) / 2, 20);
                    return;
                }

                if (!this.p1.isFixed) {
                    this.p1.x -= offsetX;
                    this.p1.y -= offsetY;
                }
                if (!this.p2.isFixed) {
                    this.p2.x += offsetX;
                    this.p2.y += offsetY;
                }
            }

            draw() {
                if (!this.visible) return;
                ctx.beginPath();
                ctx.lineWidth = this.width;
                ctx.strokeStyle = this.color;
                ctx.moveTo(this.p1.x, this.p1.y);
                ctx.lineTo(this.p2.x, this.p2.y);
                ctx.stroke();
            }
        }

        class Particle {
            constructor(x, y, type = 'fire') {
                this.x = x;
                this.y = y;
                this.type = type;
                this.life = 1.0;

                if (this.type === 'blood') {
                    this.vx = (Math.random() - 0.5) * 8;
                    this.vy = (Math.random() - 0.5) * 8;
                    this.color = `rgb(${150 + Math.random() * 105}, 0, 0)`; 
                    this.decay = Math.random() * 0.01 + 0.01;
                    this.size = Math.random() * 3 + 1;
                } else if (this.type === 'nuke_fire') {
                    // ÌïµÌè≠Î∞ú ÌååÌã∞ÌÅ¥ (Îçî ÌÅ¨Í≥† Ïò§ÎûòÍ∞ê)
                    this.vx = (Math.random() - 0.5) * 30;
                    this.vy = (Math.random() - 0.5) * 30;
                    this.color = `hsl(${Math.random()*40 + 10}, 100%, 70%)`; // Î∞ùÏùÄ Ïò§Î†åÏßÄ/ÎÖ∏Îûë
                    this.decay = 0.01;
                    this.size = Math.random() * 10 + 5;
                } else {
                    this.vx = (Math.random() - 0.5) * 15;
                    this.vy = (Math.random() - 0.5) * 15;
                    this.color = `hsl(${Math.random()*60 + 10}, 100%, 50%)`;
                    this.decay = 0.03;
                    this.size = 4;
                }
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                
                if (this.type === 'blood') {
                    this.vy += 0.3; 
                    if (this.y > height - 2) {
                        this.life = 0; 
                        spawnPuddle(this.x, height); 
                    }
                } else {
                    this.vy += 0.2;
                }

                this.life -= this.decay;
            }
            draw() {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        // Î∞îÎã•Ïóê Í≥†Ïù∏ Ìîº Í¥ÄÎ¶¨
        class Puddle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = Math.random() * 15 + 10; // Îçî ÌÅ¨Í≤å
                this.scaleX = Math.random() * 2 + 1; 
                this.alpha = 0.8 + Math.random() * 0.2;
                this.color = `rgb(${130 + Math.random() * 50}, 0, 0)`;
            }
            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = this.color;
                ctx.translate(this.x, this.y);
                ctx.scale(this.scaleX, 0.3); 
                ctx.beginPath();
                ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        function spawnPuddle(x, y) {
            // Ï†úÌïúÏùÑ 20,000Í∞úÎ°ú ÎåÄÌè≠ ÎäòÎ¶º (ÏÑ±Îä•ÏÉÅ ÌïúÍ≥ÑÏπòÍπåÏßÄ)
            if (bloodPuddles.length > 20000) {
                bloodPuddles.shift();
            }
            bloodPuddles.push(new Puddle(x, y));
        }

        function cleanAt(x, y) {
            const cleanRadius = 50;
            for (let i = bloodPuddles.length - 1; i >= 0; i--) {
                const p = bloodPuddles[i];
                const dx = p.x - x;
                const dy = p.y - y; 
                
                if (Math.abs(dx) < cleanRadius && Math.abs(y - height) < 50) {
                    p.alpha -= 0.1; 
                    if (p.alpha <= 0) {
                        bloodPuddles.splice(i, 1);
                    }
                    if (Math.random() > 0.8) playSound('clean');
                }
            }
        }

        function updateDamageUI() {
            damageEl.innerText = `Ï∂©Í≤©Îüâ: ${totalDamage.toLocaleString()}`;
            damageEl.style.transform = "scale(1.2)";
            setTimeout(() => damageEl.style.transform = "scale(1)", 100);
        }

        function spawnBlood(x, y, intensity) {
            const count = Math.min(Math.floor(intensity * 1.5), 20);
            for(let i=0; i<count; i++) {
                particles.push(new Particle(x, y, 'blood'));
            }
        }

        let totalDamage = 0;

        function createRagdoll(x, y) {
            points = [];
            sticks = [];
            totalDamage = 0;
            updateDamageUI();

            // Ìè¨Ïù∏Ìä∏
            const head = new Point(x, y, 15);
            const neck = new Point(x, y + 20, 5);
            const shoulder = new Point(x, y + 25, 5);
            
            const elbowL = new Point(x - 30, y + 30, 5);
            const handL = new Point(x - 50, y + 30, 8);
            
            const elbowR = new Point(x + 30, y + 30, 5);
            const handR = new Point(x + 50, y + 30, 8);
            
            const pelvis = new Point(x, y + 80, 8);
            
            const kneeL = new Point(x - 15, y + 110, 5);
            const footL = new Point(x - 15, y + 150, 8);
            
            const kneeR = new Point(x + 15, y + 110, 5);
            const footR = new Point(x + 15, y + 150, 8);

            points.push(head, neck, shoulder, elbowL, handL, elbowR, handR, pelvis, kneeL, footL, kneeR, footR);

            // Ïä§Ìã±
            sticks.push(new Stick(head, neck, null, true, 8, false)); 
            sticks.push(new Stick(neck, shoulder, null, true, 8, false)); 
            
            sticks.push(new Stick(shoulder, elbowL, null, true, 2, true)); 
            sticks.push(new Stick(elbowL, handL, null, true, 2, true));
            sticks.push(new Stick(shoulder, elbowR, null, true, 2, true));
            sticks.push(new Stick(elbowR, handR, null, true, 2, true));
            
            sticks.push(new Stick(shoulder, pelvis, null, true, 8, false)); 
            
            sticks.push(new Stick(pelvis, kneeL, null, true, 2, true)); 
            sticks.push(new Stick(kneeL, footL, null, true, 2, true));
            sticks.push(new Stick(pelvis, kneeR, null, true, 2, true));
            sticks.push(new Stick(kneeR, footR, null, true, 2, true));

            // Î≥¥Ï°∞ Íµ¨Ï°∞
            sticks.push(new Stick(head, shoulder, null, false)); 
            sticks.push(new Stick(shoulder, handL, null, false));
            sticks.push(new Stick(shoulder, handR, null, false));
            sticks.push(new Stick(pelvis, footL, null, false));
            sticks.push(new Stick(pelvis, footR, null, false));
            sticks.push(new Stick(kneeL, kneeR, null, false));
        }

        function setMode(newMode) {
            mode = newMode;
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            if(newMode === 'drag') document.getElementById('btn-drag').classList.add('active');
            if(newMode === 'boom') document.getElementById('btn-boom').classList.add('active');
            if(newMode === 'nuke') document.getElementById('btn-nuke').classList.add('active');
            if(newMode === 'clean') document.getElementById('btn-clean').classList.add('active');
        }

        function toggleSlow() {
            isSlowMotion = !isSlowMotion;
            document.getElementById('btn-slow').classList.toggle('active');
        }

        function toggleGravity() {
            if (gravity === 0) {
                gravity = originalGravity;
                document.getElementById('btn-gravity').classList.remove('active');
            } else {
                gravity = 0;
                document.getElementById('btn-gravity').classList.add('active');
            }
        }

        function resetRagdoll() {
            createRagdoll(width / 2, height / 3);
            bloodPuddles = []; 
        }

        function explode(x, y, force, type='fire') {
            for(let i=0; i<20; i++) particles.push(new Particle(x, y, type));
            
            points.forEach(p => {
                const dx = p.x - x;
                const dy = p.y - y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < 400) { // Ìè≠Î∞ú Î≤îÏúÑ Ï¶ùÍ∞Ä
                    const power = (1 - dist / 400) * force;
                    p.oldx -= (dx / dist) * power;
                    p.oldy -= (dy / dist) * power;
                    
                    // ÌïµÌè≠Î∞ú Ïãú Îçî Ïûò Î∂ÄÏÑúÏßê
                    if(force > 100) {
                         p.oldx -= (Math.random()-0.5) * 20; // ÎûúÎç§ Ï∂©Í≤© Ï∂îÍ∞Ä
                    }
                }
            });
        }

        // Ïó∞ÏáÑ ÌïµÌè≠Î∞ú Î°úÏßÅ
        function triggerNuke(x, y) {
            playSound('nuke_start');
            flashOpacity = 1.0; // ÌôîÎ©¥ ÌôîÏù¥Ìä∏ÏïÑÏõÉ

            // 10Î≤àÏùò Ïó∞ÏáÑ Ìè≠Î∞ú ÏòàÏïΩ
            for(let i=0; i<10; i++) {
                setTimeout(() => {
                    // ÏúÑÏπòÎ•º ÏïΩÍ∞Ñ ÎûúÎç§ÌïòÍ≤å Î∂ÑÏÇ∞
                    const offsetX = (Math.random() - 0.5) * 200;
                    const offsetY = (Math.random() - 0.5) * 200;
                    
                    // Ìè≠Î∞úÎ†• 150 (ÏùºÎ∞ò Ìè≠ÌÉÑÏùò 3Î∞∞)
                    explode(x + offsetX, y + offsetY, 150, 'nuke_fire'); 
                    playSound('boom', 2.0); // Îçî ÌÅ∞ ÏÜåÎ¶¨
                    shakeIntensity = 30; // Í∞ïÌïú ÌôîÎ©¥ ÌùîÎì§Î¶º
                }, i * 150); // 0.15Ï¥à Í∞ÑÍ≤©ÏúºÎ°ú ÌÑ∞Ïßê
            }
        }

        function checkReassembly() {
            sticks.forEach(s => {
                if (!s.visible && s.isBreakable) {
                    const dx = s.p1.x - s.p2.x;
                    const dy = s.p1.y - s.p2.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < reassembleDistance * 2.5) {
                         ctx.beginPath();
                         ctx.strokeStyle = '#0f0';
                         ctx.lineWidth = 1;
                         ctx.setLineDash([5, 5]);
                         ctx.moveTo(s.p1.x, s.p1.y);
                         ctx.lineTo(s.p2.x, s.p2.y);
                         ctx.stroke();
                         ctx.setLineDash([]);
                    }

                    if (dist < reassembleDistance) {
                        s.visible = true;
                        playSound('reassemble');
                        spawnBlood((s.p1.x + s.p2.x) / 2, (s.p1.y + s.p2.y) / 2, 5);
                    }
                }
            });
        }

        // ÏûÖÎ†• Ï≤òÎ¶¨
        function handleStart(x, y) {
            initAudio();
            isMouseDown = true;
            mouseX = x;
            mouseY = y;

            if (mode === 'drag') {
                let nearest = null;
                let minDist = 100;
                points.forEach(p => {
                    const dx = p.x - mouseX;
                    const dy = p.y - mouseY;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = p;
                    }
                });
                if (nearest) dragPoint = nearest;
            } else if (mode === 'boom') {
                explode(mouseX, mouseY, 50); 
            } else if (mode === 'clean') {
                cleanAt(mouseX, mouseY);
            } else if (mode === 'nuke') {
                triggerNuke(mouseX, mouseY);
            }
        }

        function handleMove(x, y) {
            mouseX = x; 
            mouseY = y;
            if (isMouseDown && mode === 'clean') {
                cleanAt(mouseX, mouseY);
            }
        }

        canvas.addEventListener('mousedown', (e) => handleStart(e.clientX, e.clientY));
        canvas.addEventListener('mousemove', (e) => handleMove(e.clientX, e.clientY));
        window.addEventListener('mouseup', () => { isMouseDown = false; dragPoint = null; });
        
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); 
            handleStart(e.touches[0].clientX, e.touches[0].clientY);
        }, {passive: false});

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); 
            handleMove(e.touches[0].clientX, e.touches[0].clientY);
        }, {passive: false});

        canvas.addEventListener('touchend', () => {
            isMouseDown = false;
            dragPoint = null;
        });

        resetRagdoll();

        function animate() {
            ctx.clearRect(0, 0, width, height);

            // ÌôîÎ©¥ ÌùîÎì§Î¶º Ìö®Í≥º
            if (shakeIntensity > 0) {
                const dx = (Math.random() - 0.5) * shakeIntensity;
                const dy = (Math.random() - 0.5) * shakeIntensity;
                ctx.save();
                ctx.translate(dx, dy);
                shakeIntensity *= 0.9; // ÌùîÎì§Î¶º Í∞êÏÜå
                if(shakeIntensity < 1) shakeIntensity = 0;
            }

            // Î∞îÎã•Ïóê Í≥†Ïù∏ Ìîº Í∑∏Î¶¨Í∏∞ (Ï∫êÎ¶≠ÌÑ∞Î≥¥Îã§ Îí§Ïóê)
            bloodPuddles.forEach(p => p.draw());

            if (dragPoint) {
                dragPoint.x = mouseX;
                dragPoint.y = mouseY;
                dragPoint.oldx = mouseX - (mouseX - dragPoint.oldx) * 0.5;
                dragPoint.oldy = mouseY - (mouseY - dragPoint.oldy) * 0.5;
            }

            const loops = isSlowMotion ? 1 : stiffness; 
            
            points.forEach(p => p.update());
            for (let i = 0; i < loops; i++) {
                sticks.forEach(s => s.update());
            }

            checkReassembly();

            sticks.forEach(s => s.draw());
            points.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#fff';
                ctx.fill();
            });
            
            // Î®∏Î¶¨ Í∑∏Î¶¨Í∏∞
            const head = points[0];
            if(head) {
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(head.x - 4, head.y - 2, 2, 0, Math.PI*2);
                ctx.arc(head.x + 4, head.y - 2, 2, 0, Math.PI*2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(head.x, head.y + 5, 3, 0, Math.PI*2);
                ctx.fill();
            }

            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                particles[i].draw();
                if(particles[i].life <= 0) particles.splice(i, 1);
            }

            // Ïª§ÏÑú ÌëúÏãú
            if(mode === 'boom') {
                ctx.beginPath();
                ctx.arc(mouseX, mouseY, 20, 0, Math.PI*2);
                ctx.strokeStyle = 'rgba(255, 50, 50, 0.5)';
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
            } else if (mode === 'clean') {
                ctx.beginPath();
                ctx.arc(mouseX, mouseY, 30, 0, Math.PI*2);
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
                ctx.stroke();
                ctx.font = "20px Arial";
                ctx.fillStyle = "white";
                ctx.fillText("üßπ", mouseX - 10, mouseY + 10);
            } else if (mode === 'nuke') {
                ctx.beginPath();
                ctx.arc(mouseX, mouseY, 40, 0, Math.PI*2);
                ctx.strokeStyle = 'rgba(255, 100, 0, 0.8)';
                ctx.lineWidth = 2;
                ctx.stroke();
                // Î∞©ÏÇ¨Îä• ÎßàÌÅ¨ Ïã¨Î≥º (Í∞ÑÎã®ÌïòÍ≤å)
                ctx.beginPath();
                ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';
                ctx.arc(mouseX, mouseY, 10, 0, Math.PI*2);
                ctx.fill();
                ctx.font = "24px Arial";
                ctx.fillStyle = "yellow";
                ctx.fillText("‚ò¢Ô∏è", mouseX - 12, mouseY + 8);
            }

            // ÌôîÎ©¥ ÌùîÎì§Î¶º Î≥µÍµ¨
            if (shakeIntensity >= 0 && shakeIntensity < 100 && ctx.getTransform().e !== 0) { 
                 ctx.restore();
            } else if (shakeIntensity > 0) {
                 ctx.restore();
            }

            // ÌïµÌè≠Î∞ú ÏÑ¨Í¥ë (Flash Effect)
            if (flashOpacity > 0) {
                ctx.fillStyle = `rgba(255, 255, 255, ${flashOpacity})`;
                ctx.fillRect(0, 0, width, height);
                flashOpacity -= 0.02; // ÏÑúÏÑúÌûà ÏÇ¨ÎùºÏßê
            }

            if(isSlowMotion) {
                requestAnimationFrame(() => { setTimeout(animate, 20); });
            } else {
                requestAnimationFrame(animate);
            }
        }

        animate();

    </script>
</body>
</html>